# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AnswerEntity {
  answered: Boolean!
  id: String!
  isCorrect: Boolean!
  text: String!
}

input AnswerInput {
  answered: Boolean!
  id: String!
  isCorrect: Boolean!
  text: String!
}

input ApplicantsIdsInput {
  hasSome: String!
}

type CaseConnection {
  edges: [CaseEdges!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CaseEdges {
  cursor: String!
  node: CaseEntity!
}

type CaseEntity {
  applicantsIds: [String!]!
  createdAt: DateTime!
  employeesIds: [String!]
  employerCompanyId: String
  id: String!
  isPrivate: Boolean
  name: String!
  providerCompanyId: String
  providersIds: [String!]
  status: CaseStatus!
  updatedAt: DateTime!
}

enum CaseStatus {
  APPROVED
  CANCELLED
  PENDING
  REJECTED
  REVIEW
  SENT
  UNASSIGNED
}

type Compensation {
  currency: String
  employeeId: String!
  gross: Int!
  id: String!
  net: Int
  paymentType: String!
  paymentsPerMonth: Int
  startDate: DateTime!
  totalCost: Int!
}

input CreateCaseInput {
  applicantsIds: [String!]!
  employeesIds: [String!] = []
  isPrivate: Boolean = false
  name: String!
  providersIds: [String!] = []
}

input CreateCompensationInput {
  currency: String
  employeeId: String!
  gross: Int!
  net: Int
  paymentType: String!
  paymentsPerMonth: Int
  startDate: DateTime!
  totalCost: Int!
}

input CreateProviderCompanyInput {
  email: String!
  firstName: String!
  lastName: String!
  middleName: String = ""
  name: String!
  password: String!
  website: String
}

input CreateQuestionGroupInput {
  name: String!
}

input CreateQuestionInput {
  answers: [AnswerInput!]
  points: Float!
  questionGroup: String
  text: String!
}

input CreateTestInput {
  employeeId: String
  endsAt: DateTime
  name: String!
  percentageScored: Int
  percentageToPass: Int!
  questionIds: [String!]!
  timeLimit: Int
}

input CreateTimeOffInput {
  forYear: Int!
  name: String!
  totalDays: Int!
}

input CreateTimeOffRequestInput {
  endDate: DateTime
  reason: String!
  requestedById: String!
  startDate: DateTime
  timeOffId: String!
}

input CreateUserInput {
  email: String!
  firstName: String!
  lastName: String!
  middleName: String
  password: String!
  userRole: UserRoles!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input EmployeeStatusFilterInput {
  contains: String
  eq: String
  in: [String!]
  not: String
}

enum EmploymentStatus {
  ACTIVE
  INACTIVE
  PENDING
  TERMINATED
}

input FilterInput {
  contains: String
  employeeStatus: EmployeeStatusFilterInput
  eq: String
}

type Mutation {
  createCase(args: CreateCaseInput!): MutationReturn!
  createCompensation(createCompensationInput: CreateCompensationInput!): Compensation!
  createProviderCompany(args: CreateProviderCompanyInput!): MutationReturn!
  createQuestion(createQuestionInput: CreateQuestionInput!): QuestionEntity!
  createQuestionGroup(createQuestionGroupInput: CreateQuestionGroupInput!): QuestionGroupEntity!
  createTest(createTestInput: CreateTestInput!): TestEntity!
  createTimeOff(createTimeOffInput: CreateTimeOffInput!): TimeOffEntity!
  createTimeOffRequest(createTimeOffRequestInput: CreateTimeOffRequestInput!): TimeOffRequestEntity!
  createUser(args: CreateUserInput!): MutationReturn!
  removeCompensation(id: Int!): Compensation!
  removeUser(id: String!): UserEntity!
  updateCase(args: UpdateCaseInput!): MutationReturn!
  updateQuestion(updateQuestionInput: UpdateQuestionInput!): QuestionEntity!
  updateTest(updateTestInput: UpdateTestInput!): TestEntity!
  updateTimeOff(updateTimeOffInput: UpdateTimeOffInput!): TimeOffEntity!
  updateTimeOffRequest(updateTimeOffRequestInput: UpdateTimeOffRequestInput!): TimeOffRequestEdgesEntity!
  updateUser(args: UpdateUserInput!): UserEntity!
}

type MutationReturn {
  error: String
  errorMsg: String
  isCompleted: Boolean!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PaginationInput {
  cursor: String
  orderBy: String
  skip: Int
  take: Int
}

type ProviderCompanyEntity {
  cases: CaseConnection!
  createdAt: DateTime!
  email: String!
  employees: [UserEntity!]!
  id: String!
  name: String!
  rating: Int!
  updatedAt: DateTime!
  website: String
}

type Query {
  case(id: String!): CaseEntity!
  cases: CaseConnection!
  compensation(id: Int!): Compensation!
  findAllQuestion(QueryOptionsInput: QueryOptionsInput): QuestionEntityEdgesEntity!
  findAllQuestionGroups(QueryOptionsInput: QueryOptionsInput): QuestionGroupsEntityEdgesEntity!
  findAllTests(QueryOptionsInput: QueryOptionsInput): TestsEntityEdgesEntity!
  findTestById(id: String!): TestEntity!
  providerCompany(id: String!): ProviderCompanyEntity!
  timeOffs: TimeOffConnection!
  timeOffsByUserId(employeeId: String!, forYear: Float!): TimeOffConnection!
  userById(id: String!): UserEntity!
  users(args: QueryOptionsInput): UserConnection!
}

input QueryOptionsInput {
  filters: FilterInput
  pagination: PaginationInput
}

type QuestionEdges {
  cursor: String!
  node: QuestionEntity!
}

type QuestionEntity {
  answerType: String
  answers: [AnswerEntity!]
  id: String!
  points: Float!
  questionGroup: QuestionGroupEntity
  testId: String
  text: String!
}

type QuestionEntityEdgesEntity {
  edges: [QuestionEdges!]!
  totalCount: Int!
}

type QuestionGroupEntity {
  Question: [QuestionEntity!]
  id: String!
  name: String!
}

type QuestionGroupsEdges {
  cursor: String!
  node: QuestionGroupEntity!
}

type QuestionGroupsEntityEdgesEntity {
  edges: [QuestionGroupsEdges!]!
  totalCount: Int!
}

type TestEntity {
  createdAt: DateTime
  employeeId: String
  endsAt: DateTime
  id: String!
  name: String!
  percentageScored: Int
  percentageToPass: Int!
  questions: [QuestionEntity!]!
  startedAt: DateTime
  timeLimit: Int
}

type TestsEdges {
  cursor: String!
  node: TestEntity!
}

type TestsEntityEdgesEntity {
  edges: [TestsEdges!]!
  totalCount: Int!
}

type TimeOffConnection {
  edges: [TimeOffEdges!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TimeOffEdges {
  cursor: String!
  node: TimeOffEntity!
}

type TimeOffEntity {
  employee: UserEntity
  employeeId: String
  forYear: Int!
  id: String!
  name: String!
  pendingDays: Int!
  remainingDays: Int!
  timeOffRequests(timeOffRequestQueryOptions: TimeOffRequestQueryOptions): TimeOffRequestEdgesEntity!
  totalDays: Int!
  usedDays: Int!
}

type TimeOffRequestEdges {
  cursor: String!
  node: TimeOffRequestEntity!
}

type TimeOffRequestEdgesEntity {
  edges: [TimeOffRequestEdges!]!
  totalCount: Int!
}

type TimeOffRequestEntity {
  approvedAt: DateTime
  approvedById: String
  createdAt: DateTime
  declinedAt: DateTime
  endDate: DateTime
  id: String!
  reason: String!
  requestedById: String!
  startDate: DateTime
  timeOffId: String!
}

input TimeOffRequestQueryOptions {
  approvedById: String
  isApproved: Boolean
  isDeclined: Boolean
  requestedById: String
  timeOffId: String
}

input UpdateCaseInput {
  applicantsIds: [String!]
  employeesIds: [String!] = []
  employerCompanyId: String
  id: String!
  isPrivate: Boolean = false
  name: String
  providerCompanyId: String
  providersIds: [String!] = []
  status: CaseStatus
}

input UpdateQuestionInput {
  answeredIds: [String!]!
  id: String!
}

input UpdateTestInput {
  employeeId: String
  endsAt: DateTime
  id: String!
  name: String
  percentageScored: Int
  percentageToPass: Int
  questionIds: [String!]
  startedAt: DateTime!
  timeLimit: Int
}

input UpdateTimeOffInput {
  approvedDays: Int
  employeeId: String
  forYear: Int
  name: String
  remainingDays: Int
  timeOffId: String!
  totalDays: Int
  usedDays: Int
}

input UpdateTimeOffRequestInput {
  approvedAt: DateTime
  approvedBy: String!
  declinedAt: DateTime
  id: String!
}

input UpdateUserInput {
  email: String
  employmentStatus: EmploymentStatus
  firstName: String
  id: String!
  lastName: String
  middleName: String
  password: String
  providerCompanyId: String
  userRole: UserRoles
}

type UserConnection {
  edges: [UserEdges!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdges {
  cursor: String!
  node: UserEntity!
}

type UserEntity {
  birthday: DateTime
  case(id: String!): CaseEntity!
  cases(args: UserQueryOptionsInput): CaseConnection!
  createdAt: DateTime!
  email: String!
  employmentStatus: EmploymentStatus!
  family: [UserEntity!]
  firstName: String!
  id: String!
  lastName: String!
  middleName: String!
  password: String!
  providerCompanyId: String
  userRole: UserRoles!
}

input UserQueryOptionsInput {
  userId: String
  where: UserWhereInput!
}

enum UserRoles {
  ADMIN
  CUSTOMER
  EMPLOYER_EMPLOYEE
  EMPLOYER_SUPERVISOR
  PROVIDER_EMPLOYEE
  PROVIDER_SUPERVISOR
  SUPER_ADMIN
}

input UserWhereInput {
  applicationId: ApplicantsIdsInput!
}